Unicode Sets
Format
Certain fields have sets of characters (and strings) as values, called Unicode Sets. These have the following format in CLDR 44 or later:
Each character or string is separated from others by a space. For example, the following are letters used in Croatian. Notice that dž, lj, and nj have no spaces between them: that means that they are strings, not single characters.
a b c č ć d dž đ e f g h i j k l lj m n nj o p r s š t u v z ž
Be careful not to omit the spaces: ab c is not the same as a b c!
A range of characters can be represented with the ➖ character. For example
A➖E is equivalent to A B C D E
가➖힣 is equivalent to typing 11,172 separate characters
Special characters can be represented by ❰…❱, called an escape.
For example, ❰NBSP❱ represents a non-breaking space.
Any character can also be represented by its Hex value. Thus typing either φ or ❰03C6❱ has the same effect.
See the table on the left; you can copy an escape from the left column to insert into a Unicode Set
The ➖, ❰, and ❱ characters are chosen to be unusual, so that it is unlikely that they would be normally among the characters you would want to have in a set such as the punctuation characters used in your language
You can add characters in any order: they'll be displayed in the default order for your locale. Exceptions are very large character sets like Korean Hangul, which use a code point order so that they can make use of the ➖ character.
In CLDR 43 and previous versions, a different format was used, one that require special "escapes" for certain characters and for strings. This caused problems for many people, and was replaced by the simpler format above.
Examples
In the info panel, a mouse hover over the non-winning values shows a comparison to the Winning value. The ➕ { } indicates that { and } are additions to the Winning value, and ➖ ‐ – … ' ‘ ’ " “ ” § @ * / & # † ′ ″ indicates that ➖, ‐. –. …. and so on are subtractions from the Winning value. That makes it much easier to see what the difference in the outcome would be.
The very last line shows an internal UnicodeSet format. You can normally ignore this. However, if you want more details about the characters you can copy the [...] from that line in the Info Panel and paste that into the Input box on UnicodeSet (and hit Show Set) to see more information about the characters, such as [!(),-.\:;?\[\]\{\}‑].
Table of Contents
Format
Examples
Exemplar Characters
Parse Characters
Handling Warnings in Exemplar characters
Key to Escapes
Examplar Examples
Exemplar Characters
The exemplar character sets contain the commonly used letters for a given modern form of a language. These are used for testing and for determining the appropriate repertoire of letters for various tasks, like choosing charset converters that can handle a given language. The term “letter” is interpreted broadly, and includes characters used to form words, such as 是 or 가. It should not include presentation forms, like U+FE90 ( ‎ﺐ‎ ) ARABIC LETTER BEH FINAL FORM, or isolated Jamo characters (for Hangul).
For charts of the standard (non-CJK) exemplar characters, see a chart of the standard exemplar characters.
For more information, please see Section 5.6 Character Elements in UTS#35: Locale Data Markup Language (LDML).
There are different categories:
Examplar Examples
Parse Characters
These are sets of characters that are treated as equivalent in parsing. In the Code column you'll see a description of the characters with a sample in parentheses. For example, the following indicates that in date/time parsing, when someone types any of the characters in the Winning column, they should be treated as equivalent to ":".
Note that if your language doesn't use any of these characters in date and times, the value doesn't really matter, and you can simply vote for the default value. For example, if a time is represented by "3.20" instead of "3:20", then it doesn't matter which characters are equivalent to ":".
Handling Warnings in Exemplar characters
There are two kinds of warnings you can get with Exemplar Characters. While these are categorized as warnings, every effort should be made to fix them.
A. A particular translated item contains characters that aren't in the exemplars.
For example:
Suppose the currency code XAF is translated as "Φράγκο BEAC CFA" in Greek. That raises a warning because the "BEAC CFA" are not in the Greek exemplars.
Suppose that a currency symbol contains ৲ (BENGALI RUPEE MARK). That also raises a warning, even though it is a symbol and not a letter, because it has a script (Bengali).
Three possible solutions:
If the character really is used in the language, add it to the appropriate exemplar set (standard, auxiliary,…).
For example, the Bengali Rupee mark should be added to the currency exemplar set.
To add to the Exemplar Characters, go first to the main view for your locale, then select Other Items [Characters]. For example, see German characters.
For currencies, if the character is part of a 'gloss', that is, it is parenthetically included for reference, and the gloss is all ASCII, then include it in brackets. You can use [square brackets] or (parentheses) in currencies. Everywhere else, please use only square brackets.
So the XAF above can be fixed by changing it to "Φράγκο [BEAC CFA]" or "Φράγκο (BEAC CFA)". For the timezone name "ACT (Ακρ)", the fix is to change to "Ακρ [ACT]".
If neither of these approaches is appropriate, try rephrasing the translated item to avoid the character.
If it really can't be avoided, then please file a new ticket describing the problem.
B. The exemplar characters shouldn't contain a particular character.
The standard characters shouldn't contain punctuation. They also should not contain symbols, unless those symbols are only used with the language's writing system (aka script). For example, the standard Bengali currency symbols should contain the Bengali Rupee mark (which is Bengali-only), but should not include the $ Dollar Sign (which is common across all scripts).